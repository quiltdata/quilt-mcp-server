# Production/packaging targets
# MCPB packaging system

# Paths
APP_DIR := src
ASSETS_DIR := src/deploy
BUILD_DIR := build
BUILD_PKGS_DIR := $(BUILD_DIR)/lib
DIST_DIR := dist

# Variables
PACKAGE_NAME := quilt-mcp
# Allow VERSION to be overridden from command line, otherwise read from pyproject.toml
MANIFEST_VERSION := $(shell python3 scripts/version.py get-version 2>/dev/null || echo "dev")
PACKAGE_VERSION := $(if $(VERSION),$(VERSION),$(MANIFEST_VERSION))
PACKAGE_ID := $(DIST_DIR)/$(PACKAGE_NAME)-$(PACKAGE_VERSION)
MCPB_PACKAGE := $(PACKAGE_ID).mcpb
RELEASE_ZIP := $(PACKAGE_ID)-release.zip


# Source file dependencies
ASSET_FILES := $(wildcard $(ASSETS_DIR)/*)
APP_FILES := $(shell find $(APP_DIR)/quilt_mcp -name "*.py" 2>/dev/null || true)

.PHONY: deploy-build mcpb mcpb-validate python-dist python-publish release-zip deploy-clean check-tools docker-build docker-build-amd64 docker-push docker-push-amd64 docker-push-dev docker-tools ecs-deploy ecs-deploy-no-wait docker-release docker-release-dev

# Check for required tools
check-tools:
	@command -v npx >/dev/null 2>&1 || { echo "‚ùå npx not found - install Node.js"; exit 1; }
	@command -v uv >/dev/null 2>&1 || { echo "‚ùå uv not found - install uv package manager"; exit 1; }
	@command -v mcpb >/dev/null 2>&1 || { echo "‚ùå mcpb not found - run: npm install -g @anthropic-ai/mcpb"; exit 1; }
	@echo "‚úÖ All required tools found"

# Build Environment Preparation
deploy-build: check-tools
	@echo "Preparing production build environment..."
	@$(MAKE) -f make.deploy mcpb-build-contents
	@echo "‚úÖ Build environment ready"


# Intermediate targets for incremental builds
# MCPB assets (only manifest, icon, README needed)
mcpb-assets: $(ASSET_FILES)
	@echo "Preparing MCPB assets..."
	@mkdir -p $(BUILD_DIR)/mcpb
	@echo "Generating manifest.json from template..."
	@sed 's/{{ version }}/$(PACKAGE_VERSION)/g' $(ASSETS_DIR)/manifest.json.j2 > $(BUILD_DIR)/mcpb/manifest.json
	@echo "Copying icon and documentation..."
	@cp $(ASSETS_DIR)/icon.png $(BUILD_DIR)/mcpb/
	@cp $(ASSETS_DIR)/README.md $(BUILD_DIR)/mcpb/
	@echo "‚úÖ MCPB assets prepared"


# MCPB simplified build (no source code copying needed)
mcpb-build-contents: mcpb-assets
	@echo "‚úÖ MCPB build contents prepared"



# MCPB Package Creation
$(MCPB_PACKAGE): mcpb-build-contents
	@echo "Packing with MCPB CLI..."
	@mkdir -p $(DIST_DIR)
	@mcpb pack $(BUILD_DIR)/mcpb $(MCPB_PACKAGE)
	@echo "‚úÖ Built $(MCPB_PACKAGE)"

mcpb: $(MCPB_PACKAGE)
	@echo "‚úÖ MCPB package created: $(MCPB_PACKAGE)"


# Python Package Distribution
python-dist: check-tools
	@echo "üöÄ Building Python artifacts..."
	@mkdir -p $(DIST_DIR)
	@uv sync --group dev
	@uv run python -m build --wheel --sdist --outdir $(DIST_DIR)
	@echo "‚úÖ Python packaging complete"

python-publish:
	@./scripts/release.sh python-publish

# MCPB Package Validation
mcpb-validate: check-tools mcpb
	@echo "üîç Comprehensive MCPB package validation..."
	@echo "\n1. Validating with MCPB CLI..."
	@mcpb info $(MCPB_PACKAGE)
	@echo "\n2. Validating generated manifest.json..."
	@mcpb validate $(BUILD_DIR)/mcpb/manifest.json
	@echo "\n3. Validating package structure..."
	@test -f $(BUILD_DIR)/mcpb/manifest.json || { echo "‚ùå manifest.json missing"; exit 1; }
	@test -f $(BUILD_DIR)/mcpb/icon.png || { echo "‚ùå icon.png missing"; exit 1; }
	@test -f $(BUILD_DIR)/mcpb/README.md || { echo "‚ùå README.md missing"; exit 1; }
	@echo "‚úÖ Package structure validation passed"
	@echo "\n4. Validating manifest content..."
	@grep -q '"name": "quilt-mcp"' $(BUILD_DIR)/mcpb/manifest.json || { echo "‚ùå Invalid name in manifest"; exit 1; }
	@grep -q '"version": "$(PACKAGE_VERSION)"' $(BUILD_DIR)/mcpb/manifest.json || { echo "‚ùå Invalid version in manifest"; exit 1; }
	@grep -q '"entry_point": "uvx"' $(BUILD_DIR)/mcpb/manifest.json || { echo "‚ùå Invalid entry_point in manifest"; exit 1; }
	@grep -q '"args": \["quilt-mcp"\]' $(BUILD_DIR)/mcpb/manifest.json || { echo "‚ùå Invalid args in manifest"; exit 1; }
	@echo "‚úÖ Manifest content validation passed"
	@echo "\n5. Testing UVX execution compatibility..."
	@uvx --from . quilt-mcp --help >/dev/null 2>&1 || { echo "‚ùå UVX execution test failed"; exit 1; }
	@echo "‚úÖ UVX execution test passed"
	@echo "\n6. Running prerequisites validation..."
	@bash $(ASSETS_DIR)/check-mcpb.sh >/dev/null 2>&1 || { echo "‚ùå Prerequisites validation failed"; exit 1; }
	@echo "‚úÖ Prerequisites validation passed"
	@echo "\n‚úÖ Comprehensive MCPB package validation passed"


# Release Bundle Creation
$(RELEASE_ZIP): mcpb-validate $(ASSETS_DIR)/README.md $(ASSETS_DIR)/check-mcpb.sh
	@echo "Creating release bundle..."
	@mkdir -p $(DIST_DIR)/release
	@cp $(MCPB_PACKAGE) $(DIST_DIR)/release/
	@cp $(ASSETS_DIR)/README.md $(DIST_DIR)/release/
	@cp $(ASSETS_DIR)/check-mcpb.sh $(DIST_DIR)/release/
	@cd $(DIST_DIR)/release && zip -r ../$(PACKAGE_NAME)-$(PACKAGE_VERSION)-release.zip .
	@rm -rf $(DIST_DIR)/release
	@echo "‚úÖ Built $(RELEASE_ZIP)"

release-zip: $(RELEASE_ZIP)
	@echo "‚úÖ Release bundle $(RELEASE_ZIP) ready for distribution"

# Docker Operations
#
# Configuration (can be overridden):
#   ECS_CLUSTER       - ECS cluster name (default: quilt-mcp-cluster)
#   ECS_SERVICE       - ECS service name (default: quilt-mcp-service)
#   ECS_TASK_FAMILY   - Task definition family (default: quilt-mcp-task)
#   DOCKER_PLATFORM   - Target platform (default: linux/amd64 for ECS)
#   AWS_REGION        - AWS region (default: us-east-1)

ECS_CLUSTER ?= quilt-mcp-cluster
ECS_SERVICE ?= quilt-mcp-service
ECS_TASK_FAMILY ?= quilt-mcp-task
AWS_REGION ?= us-east-1
DOCKER_PLATFORM ?= linux/amd64

docker-tools:
	@command -v docker >/dev/null 2>&1 || { echo "‚ùå Docker not found - install Docker"; exit 1; }
	@docker info >/dev/null 2>&1 || { echo "‚ùå Docker daemon not running or not accessible"; exit 1; }
	@echo "‚úÖ Docker tools available"
	@echo "üîç Checking ECR repository..."
	@aws ecr describe-repositories --repository-names quilt-mcp-server --region $(AWS_REGION) >/dev/null 2>&1 || \
		{ echo "üì¶ Creating ECR repository..." && aws ecr create-repository --repository-name quilt-mcp-server --region $(AWS_REGION) >/dev/null; }
	@echo "‚úÖ ECR repository ready"
	@echo "üîê Authenticating with ECR..."
	@aws ecr get-login-password --region $(AWS_REGION) | docker login --username AWS --password-stdin 712023778557.dkr.ecr.$(AWS_REGION).amazonaws.com >/dev/null 2>&1
	@echo "‚úÖ ECR authentication successful"

docker-build: docker-tools
	@echo "üê≥ Building Docker image locally..."
	@uv run python scripts/docker.py build
	@echo "‚úÖ Docker build completed"

docker-build-amd64: docker-tools
	@echo "üê≥ Building Docker image for AMD64..."
	@DOCKER_PLATFORM=linux/amd64 uv run python scripts/docker.py build
	@echo "‚úÖ AMD64 Docker build completed"

docker-push: docker-tools
	@echo "üê≥ Building and pushing Docker image..."
	@VERSION=$(PACKAGE_VERSION) uv run python scripts/docker.py push --version $(PACKAGE_VERSION)
	@echo "‚úÖ Docker push completed"

docker-push-amd64: docker-tools
	@echo "üê≥ Building and pushing Docker image for AMD64..."
	@VERSION=$(PACKAGE_VERSION) DOCKER_PLATFORM=linux/amd64 uv run python scripts/docker.py push --version $(PACKAGE_VERSION) --platform linux/amd64
	@echo "‚úÖ AMD64 Docker push completed"

docker-push-dev: docker-tools
	@echo "üê≥ Building and pushing development Docker image..."
	@DEV_VERSION="$(PACKAGE_VERSION)-dev-$(shell date +%Y%m%d%H%M%S)" && \
	echo "Using development version: $$DEV_VERSION" && \
	VERSION=$$DEV_VERSION uv run python scripts/docker.py push --version $$DEV_VERSION --no-latest
	@echo "‚úÖ Development Docker push completed"

# ECS Deployment Operations

ecs-deploy: docker-tools
	@echo "üöÄ Deploying to ECS..."
	@if [ -z "$(IMAGE_URI)" ]; then \
		echo "‚ùå IMAGE_URI is required. Use: make ecs-deploy IMAGE_URI=<uri>"; \
		exit 1; \
	fi
	@uv run python scripts/ecs_deploy.py \
		--image $(IMAGE_URI) \
		--cluster $(ECS_CLUSTER) \
		--service $(ECS_SERVICE) \
		--task-family $(ECS_TASK_FAMILY) \
		--region $(AWS_REGION)
	@echo "‚úÖ ECS deployment completed"

ecs-deploy-no-wait: docker-tools
	@echo "üöÄ Deploying to ECS (no wait)..."
	@if [ -z "$(IMAGE_URI)" ]; then \
		echo "‚ùå IMAGE_URI is required. Use: make ecs-deploy-no-wait IMAGE_URI=<uri>"; \
		exit 1; \
	fi
	@uv run python scripts/ecs_deploy.py \
		--image $(IMAGE_URI) \
		--cluster $(ECS_CLUSTER) \
		--service $(ECS_SERVICE) \
		--task-family $(ECS_TASK_FAMILY) \
		--region $(AWS_REGION) \
		--no-wait
	@echo "‚úÖ ECS deployment initiated"

# Comprehensive Release Workflow

docker-release: docker-tools
	@echo "üöÄ Complete Docker Release Workflow"
	@echo "=================================="
	@echo "Version: $(PACKAGE_VERSION)"
	@echo "Platform: $(DOCKER_PLATFORM)"
	@echo "Cluster: $(ECS_CLUSTER)"
	@echo "Service: $(ECS_SERVICE)"
	@echo ""
	@echo "Step 1/4: Building AMD64 Docker image..."
	@VERSION=$(PACKAGE_VERSION) DOCKER_PLATFORM=$(DOCKER_PLATFORM) uv run python scripts/docker.py push --version $(PACKAGE_VERSION) --platform $(DOCKER_PLATFORM)
	@echo ""
	@echo "Step 2/4: Determining image URI..."
	@IMAGE_URI=$$(VERSION=$(PACKAGE_VERSION) uv run python scripts/docker.py info --version $(PACKAGE_VERSION)) && \
	echo "Image URI: $$IMAGE_URI" && \
	echo "" && \
	echo "Step 3/4: Updating ECS task definition..." && \
	uv run python scripts/ecs_deploy.py \
		--image $$IMAGE_URI \
		--cluster $(ECS_CLUSTER) \
		--service $(ECS_SERVICE) \
		--task-family $(ECS_TASK_FAMILY) \
		--region $(AWS_REGION)
	@echo ""
	@echo "‚úÖ Complete Docker release finished successfully!"
	@echo "   Version $(PACKAGE_VERSION) is now deployed to $(ECS_SERVICE)"

docker-release-dev: docker-tools
	@echo "üöÄ Development Docker Release Workflow"
	@DEV_VERSION="$(PACKAGE_VERSION)-dev-$(shell date +%Y%m%d%H%M%S)" && \
	echo "Using development version: $$DEV_VERSION" && \
	echo "" && \
	echo "Step 1/3: Building and pushing AMD64 dev image..." && \
	VERSION=$$DEV_VERSION DOCKER_PLATFORM=$(DOCKER_PLATFORM) uv run python scripts/docker.py push --version $$DEV_VERSION --platform $(DOCKER_PLATFORM) --no-latest && \
	echo "" && \
	echo "Step 2/3: Determining image URI..." && \
	IMAGE_URI=$$(VERSION=$$DEV_VERSION uv run python scripts/docker.py info --version $$DEV_VERSION) && \
	echo "Image URI: $$IMAGE_URI" && \
	echo "" && \
	echo "Step 3/3: Updating ECS task definition..." && \
	uv run python scripts/ecs_deploy.py \
		--image $$IMAGE_URI \
		--cluster $(ECS_CLUSTER) \
		--service $(ECS_SERVICE) \
		--task-family $(ECS_TASK_FAMILY) \
		--region $(AWS_REGION)
	@echo ""
	@echo "‚úÖ Development release completed!"

# Release Tagging Targets
release-tag:
	@echo "Creating release tag..."
	@if [ "${DRY_RUN}" = "1" ]; then \
		echo "üîç DRY RUN: Would create release tag"; \
		./scripts/release.sh release --dry-run; \
	else \
		./scripts/release.sh release; \
	fi

release-dev-tag:
	@echo "Creating development tag..."
	@if [ "${DRY_RUN}" = "1" ]; then \
		echo "üîç DRY RUN: Would create development tag"; \
		./scripts/release.sh dev --dry-run; \
	else \
		./scripts/release.sh dev; \
	fi

# Cleanup Targets
deploy-clean:
	@echo "Cleaning build artifacts..."
	@rm -rf $(BUILD_DIR) $(DIST_DIR)
	@rm -f *.mcpb  # Clean MCPB packages from root
	@echo "‚úÖ Deploy cleanup completed"