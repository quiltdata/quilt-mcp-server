#!/usr/bin/env python3
"""
Coverage Threshold Validation Tests

Validates that coverage (already generated by `make coverage`) meets minimum
thresholds defined in coverage_required.yaml.

IMPORTANT: This script assumes coverage-analysis.csv already exists from
running `make coverage`. It does NOT regenerate coverage data.

Usage:
    pytest scripts/tests/test_coverage_analysis.py
    python scripts/tests/test_coverage_analysis.py

Exit Codes:
    0 - All coverage thresholds met
    1 - Coverage thresholds not met or analysis failed
"""

import csv
import sys
from pathlib import Path
from typing import Dict, List, Tuple

import pytest
import yaml


# Project paths
PROJECT_ROOT = Path(__file__).parent.parent.parent
SCRIPTS_DIR = PROJECT_ROOT / "scripts"
TEST_RESULTS_DIR = PROJECT_ROOT / "build" / "test-results"
COVERAGE_REQUIRED_YAML = SCRIPTS_DIR / "tests" / "coverage_required.yaml"
COVERAGE_CSV = TEST_RESULTS_DIR / "coverage-analysis.csv"
COVERAGE_RESULTS_YAML = SCRIPTS_DIR / "tests" / "coverage_results.yaml"


class CoverageThresholds:
    """Container for coverage threshold configuration."""

    def __init__(self, config: dict):
        self.summary = config.get("summary", {})
        self.files = config.get("files") or {}
        self.strict = config.get("strict", False)
        self.exempt_files = config.get("exempt_files") or []

    def get_file_thresholds(self, file_path: str) -> Dict[str, float]:
        """Get thresholds for a specific file, falling back to summary defaults."""
        if file_path in self.files:
            return self.files[file_path]
        return self.summary

    def is_exempt(self, file_path: str) -> bool:
        """Check if a file is exempt from coverage requirements."""
        from fnmatch import fnmatch
        return any(fnmatch(file_path, pattern) for pattern in self.exempt_files)


class CoverageReport:
    """Represents parsed coverage analysis results."""

    def __init__(self, csv_path: Path):
        self.csv_path = csv_path
        self.files: Dict[str, Dict[str, str]] = {}
        self.summary: Dict[str, str] = {}
        self._parse_csv()

    def _parse_csv(self):
        """Parse the coverage CSV file."""
        if not self.csv_path.exists():
            raise FileNotFoundError(
                f"Coverage CSV not found: {self.csv_path}\n"
                f"Did you run 'make coverage' first?"
            )

        with open(self.csv_path, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                file_path = row['file']
                if file_path == 'SUMMARY':
                    self.summary = row
                else:
                    self.files[file_path] = row

    def get_file_coverage(self, file_path: str) -> Dict[str, float]:
        """Get coverage percentages for a specific file."""
        if file_path not in self.files:
            return {}

        row = self.files[file_path]
        return {
            'unit_pct_covered': float(row['unit_pct_covered']),
            'func_pct_covered': float(row['func_pct_covered']),
            'e2e_pct_covered': float(row['e2e_pct_covered']),
            'combined_pct_covered': float(row['combined_pct_covered']),
        }

    def get_summary_coverage(self) -> Dict[str, float]:
        """Get summary coverage percentages."""
        if not self.summary:
            return {}

        return {
            'unit_pct_covered': float(self.summary['unit_pct_covered']),
            'func_pct_covered': float(self.summary['func_pct_covered']),
            'e2e_pct_covered': float(self.summary['e2e_pct_covered']),
            'combined_pct_covered': float(self.summary['combined_pct_covered']),
        }


def load_thresholds() -> CoverageThresholds:
    """Load coverage thresholds from YAML configuration."""
    if not COVERAGE_REQUIRED_YAML.exists():
        raise FileNotFoundError(
            f"Coverage thresholds config not found: {COVERAGE_REQUIRED_YAML}"
        )

    with open(COVERAGE_REQUIRED_YAML, 'r') as f:
        config = yaml.safe_load(f)

    return CoverageThresholds(config)


def validate_coverage(
    report: CoverageReport,
    thresholds: CoverageThresholds
) -> Tuple[bool, List[str], Dict]:
    """Validate coverage against thresholds.

    Args:
        report: Parsed coverage report
        thresholds: Coverage threshold configuration

    Returns:
        Tuple of (all_passed, error_messages, results_dict)
    """
    errors = []
    all_passed = True
    results = {
        'summary': {},
        'files': {},
        'passed': True,
        'errors': []
    }

    # Validate summary coverage
    summary_coverage = report.get_summary_coverage()
    summary_thresholds = thresholds.summary

    if summary_coverage:
        summary_results = {}
        for metric, threshold in summary_thresholds.items():
            actual = summary_coverage.get(metric, 0.0)
            passed = actual >= threshold
            summary_results[metric] = {
                'actual': actual,
                'required': threshold,
                'passed': passed
            }
            if not passed:
                all_passed = False
                error_msg = f"SUMMARY {metric}: {actual:.1f}% < {threshold:.1f}% (required)"
                errors.append(error_msg)
        results['summary'] = summary_results

    # Validate per-file coverage (only for explicitly configured files)
    for file_path in thresholds.files.keys():
        # Skip exempt files
        if thresholds.is_exempt(file_path):
            continue

        # Skip if file not in coverage report
        if file_path not in report.files:
            continue

        file_thresholds = thresholds.files[file_path]
        file_coverage = report.get_file_coverage(file_path)
        file_results = {}

        for metric, threshold in file_thresholds.items():
            actual = file_coverage.get(metric, 0.0)
            passed = actual >= threshold
            file_results[metric] = {
                'actual': actual,
                'required': threshold,
                'passed': passed
            }
            if not passed:
                all_passed = False
                error_msg = f"{file_path} {metric}: {actual:.1f}% < {threshold:.1f}% (required)"
                errors.append(error_msg)

        results['files'][file_path] = file_results

    results['passed'] = all_passed
    results['errors'] = errors
    return all_passed, errors, results


def write_results_yaml(results: Dict):
    """Write validation results to YAML file."""
    COVERAGE_RESULTS_YAML.parent.mkdir(parents=True, exist_ok=True)
    with open(COVERAGE_RESULTS_YAML, 'w') as f:
        yaml.dump(results, f, default_flow_style=False, sort_keys=False)


class TestCoverageThresholds:
    """Test suite for coverage threshold validation."""

    @pytest.fixture(scope="class")
    def coverage_report(self):
        """Load coverage report (assumes it already exists)."""
        report = CoverageReport(COVERAGE_CSV)
        return report

    @pytest.fixture(scope="class")
    def thresholds(self):
        """Load coverage thresholds."""
        return load_thresholds()

    def test_coverage_csv_exists(self, coverage_report):
        """Test that coverage CSV exists (generated by make coverage)."""
        assert coverage_report is not None
        assert COVERAGE_CSV.exists(), (
            f"Coverage CSV not found: {COVERAGE_CSV}\n"
            f"Run 'make coverage' first to generate coverage data."
        )

    def test_summary_coverage_meets_thresholds(self, coverage_report, thresholds):
        """Test that summary coverage meets minimum thresholds."""
        summary_coverage = coverage_report.get_summary_coverage()
        assert summary_coverage, "No summary coverage data found"

        errors = []
        for metric, threshold in thresholds.summary.items():
            actual = summary_coverage.get(metric, 0.0)
            if actual < threshold:
                errors.append(
                    f"{metric}: {actual:.1f}% < {threshold:.1f}% (required)"
                )

        assert not errors, "Summary coverage thresholds not met:\n" + "\n".join(errors)

    def test_file_coverage_meets_thresholds(self, coverage_report, thresholds):
        """Test that per-file coverage meets minimum thresholds.

        NOTE: This test is disabled by default. Coverage validation only checks
        aggregate/summary thresholds. Per-file thresholds are only checked if
        explicitly configured in coverage_required.yaml under the 'files' section.
        """
        errors = []

        # Only check files that have explicit thresholds configured
        for file_path in thresholds.files.keys():
            # Skip exempt files
            if thresholds.is_exempt(file_path):
                continue

            # Skip if file not in coverage report
            if file_path not in coverage_report.files:
                continue

            file_thresholds = thresholds.files[file_path]
            file_coverage = coverage_report.get_file_coverage(file_path)

            for metric, threshold in file_thresholds.items():
                actual = file_coverage.get(metric, 0.0)
                if actual < threshold:
                    errors.append(
                        f"{file_path} {metric}: {actual:.1f}% < {threshold:.1f}%"
                    )

        assert not errors, "File coverage thresholds not met:\n" + "\n".join(errors)


def main():
    """Main entry point for standalone execution."""
    print("=" * 70)
    print("Coverage Threshold Validation")
    print("=" * 70)

    # Load thresholds
    print("\n1. Loading coverage thresholds...")
    try:
        thresholds = load_thresholds()
        print(f"‚úÖ Loaded thresholds from {COVERAGE_REQUIRED_YAML}")
    except Exception as e:
        print(f"‚ùå Failed to load thresholds: {e}")
        return 1

    # Load coverage report (assumes already generated)
    print("\n2. Loading coverage report...")
    try:
        report = CoverageReport(COVERAGE_CSV)
        print(f"‚úÖ Loaded coverage data for {len(report.files)} files")
    except FileNotFoundError as e:
        print(f"‚ùå {e}")
        print("\nüí° Run 'make coverage' first to generate coverage data.")
        return 1
    except Exception as e:
        print(f"‚ùå Failed to load coverage report: {e}")
        return 1

    # Validate coverage
    print("\n3. Validating coverage thresholds...")
    all_passed, errors, results = validate_coverage(report, thresholds)

    # Write results to YAML
    print(f"\n4. Writing results to {COVERAGE_RESULTS_YAML}...")
    try:
        write_results_yaml(results)
        print(f"‚úÖ Results written to {COVERAGE_RESULTS_YAML}")
    except Exception as e:
        print(f"‚ö†Ô∏è  Failed to write results YAML: {e}")

    # Display results
    if all_passed:
        print("\n" + "=" * 70)
        print("‚úÖ All coverage thresholds met!")
        print("=" * 70)
        print("\nSummary Coverage:")
        summary = report.get_summary_coverage()
        for metric, value in summary.items():
            threshold = thresholds.summary.get(metric, 0.0)
            status = "‚úÖ" if value >= threshold else "‚ùå"
            print(f"  {status} {metric}: {value:.1f}% (required: {threshold:.1f}%)")
        return 0
    else:
        print("\n" + "=" * 70)
        print("‚ùå Coverage thresholds not met!")
        print("=" * 70)
        print("\nFailures:")
        for error in errors:
            print(f"  ‚ùå {error}")
        print(f"\nüí° See detailed results in {COVERAGE_RESULTS_YAML}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
