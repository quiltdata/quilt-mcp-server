# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Main Branch Validation

on:
  push:
    branches: [main]
    tags:
      - 'v*'
      - '!v*-dev-*'  # Exclude dev tags - those trigger PR workflow only
  merge_group:
    types: [checks_requested]

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        python-version: ["3.13", "3.12", "3.11"]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup build environment
      uses: ./.github/actions/setup-build-env
      with:
        python-version: ${{ matrix.python-version }}

    - name: Run comprehensive tests
      uses: ./.github/actions/run-tests
      with:
        test-target: ${{ matrix.python-version == '3.11' && 'coverage' || 'test-ci' }}
        artifact-name: test-results
        python-version: ${{ matrix.python-version }}
      env:
        # AWS credentials for tests that need them
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION || 'us-east-1' }}

        # Quilt configuration
        QUILT_DEFAULT_BUCKET: ${{ secrets.QUILT_DEFAULT_BUCKET }}
        QUILT_CATALOG_URL: ${{ secrets.QUILT_CATALOG_URL }}
        QUILT_TEST_PACKAGE: ${{ secrets.QUILT_TEST_PACKAGE }}
        QUILT_TEST_ENTRY: ${{ secrets.QUILT_TEST_ENTRY }}


  # Production release job - runs after tests pass for production tags
  prod-release:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [test]
    environment: pypi
    permissions:
      contents: write
      id-token: write
    # Only run for production tags (v* but not v*-dev-*) and only after tests pass
    if: startsWith(github.ref, 'refs/tags/v') && (!contains(github.ref, '-dev-')) && contains(needs.test.result, 'success')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup build environment
      uses: ./.github/actions/setup-build-env
      with:
        python-version: '3.11'
        include-nodejs: 'true'

    - name: Extract version from tag
      id: version
      run: |
        TAG_VERSION=${GITHUB_REF#refs/tags/v}
        echo "tag_version=$TAG_VERSION" >> $GITHUB_OUTPUT
        echo "Production Tag Version: $TAG_VERSION"

    - name: Create production release
      uses: ./.github/actions/create-release
      with:
        package-version: ${{ steps.version.outputs.tag_version }}
        # pypi-repository-url defaults to '' for PyPI

    - name: Configure AWS credentials for ECR
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_DEFAULT_REGION || 'us-east-1' }}

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and publish Docker image
      env:
        VERSION: ${{ steps.version.outputs.tag_version }}
        ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
        AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION || 'us-east-1' }}
      shell: bash
      run: |
        set -euo pipefail

        registry="$ECR_REGISTRY"
        if [ -z "$registry" ]; then
          if [ -z "$AWS_ACCOUNT_ID" ]; then
            echo "ECR registry not configured" >&2
            exit 1
          fi
          registry="$AWS_ACCOUNT_ID.dkr.ecr.${AWS_DEFAULT_REGION:-us-east-1}.amazonaws.com"
        fi

        image_tags=$(uv run python scripts/docker_image.py --registry "$registry" --version "$VERSION")

        first_tag=$(echo "$image_tags" | head -n 1)
        docker build --file Dockerfile --tag "$first_tag" .

        echo "$image_tags" | tail -n +2 | while read -r tag; do
          [ -z "$tag" ] && continue
          docker tag "$first_tag" "$tag"
        done

        echo "$image_tags" | while read -r tag; do
          [ -z "$tag" ] && continue
          docker push "$tag"
        done
