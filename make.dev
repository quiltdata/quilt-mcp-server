# Development workflow targets
# Migrated from app/Makefile for Phase 1 consolidation

# Load environment variables from .env if it exists
sinclude .env
export

# Development endpoint configuration
DEV_ENDPOINT ?= http://127.0.0.1:8001/mcp/

# Test results directory
RESULTS_DIR ?= build/test-results

.PHONY: test test-all test-unit test-integration test-e2e test-ci test-scripts lint coverage coverage-html run run-inspector kill dev-clean docker-build docker-run docker-test test-buckets-curl test-buckets-discover test-buckets-file-access test-buckets-browse test-packaging-curl test-packaging-browse test-packaging-create test-readme

# Directory targets
$(RESULTS_DIR):
	@mkdir -p $(RESULTS_DIR)

# Test Targets
test:
	@echo "Running unit tests (default)..."
	@$(MAKE) test-unit

test-all: mcpb-validate test-scripts test-readme | $(RESULTS_DIR)
	@echo "Running all tests..."
	@uv sync --group test
	@export PYTHONPATH="src" && uv run python -m pytest tests/ -v --cov=quilt_mcp --cov-report=xml:$(RESULTS_DIR)/coverage-all.xml --cov-report=term-missing


test-ci: | $(RESULTS_DIR)
	@echo "Running all tests..."
	@uv sync --group test
	@export PYTHONPATH="src" && uv run python -m pytest tests/ -v -m "not slow and not search"  --cov=quilt_mcp --cov-report=xml:$(RESULTS_DIR)/coverage-all.xml --cov-report=term-missing

test-unit: $(RESULTS_DIR)/coverage-unit.xml

$(RESULTS_DIR)/coverage-unit.xml: tests/unit/test_*.py | $(RESULTS_DIR)
	@echo "Running unit tests only (fast, mocked)..."
	@uv sync --group test
	@export PYTHONPATH="src" && uv run python -m pytest tests/unit/ -v --cov=quilt_mcp --cov-report=xml:$(RESULTS_DIR)/coverage-unit.xml --cov-report=term-missing

test-integration: $(RESULTS_DIR)/coverage-integration.xml

$(RESULTS_DIR)/coverage-integration.xml: tests/integration/test_*.py | $(RESULTS_DIR)
	@echo "Running integration tests (AWS/external services)..."
	@uv sync --group test
	@if [ -d "tests/integration" ] && [ "$$(find tests/integration -name "*.py" | wc -l)" -gt 0 ]; then \
		export PYTHONPATH="src" && uv run python -m pytest tests/integration/ -v -m "not search" --cov=quilt_mcp --cov-report=xml:$(RESULTS_DIR)/coverage-integration.xml --cov-report=term-missing; \
	else \
		echo "No integration tests found, creating empty coverage file..."; \
		echo '<?xml version="1.0" ?><coverage></coverage>' > $(RESULTS_DIR)/coverage-integration.xml; \
	fi

test-e2e: $(RESULTS_DIR)/coverage-e2e.xml

$(RESULTS_DIR)/coverage-e2e.xml: tests/e2e/test_*.py | $(RESULTS_DIR)
	@echo "Running end-to-end workflow tests..."
	@uv sync --group test
	@if [ -d "tests/e2e" ] && [ "$$(find tests/e2e -name "*.py" | wc -l)" -gt 0 ]; then \
		export PYTHONPATH="src" && uv run python -m pytest tests/e2e/ -v --cov=quilt_mcp --cov-report=xml:$(RESULTS_DIR)/coverage-e2e.xml --cov-report=term-missing; \
	else \
		echo "No e2e tests found, creating empty coverage file..."; \
		echo '<?xml version="1.0" ?><coverage></coverage>' > $(RESULTS_DIR)/coverage-e2e.xml; \
	fi

coverage: $(RESULTS_DIR)/coverage-analysis.csv | $(RESULTS_DIR)

$(RESULTS_DIR)/coverage-analysis.csv: $(RESULTS_DIR)/coverage-unit.xml $(RESULTS_DIR)/coverage-integration.xml $(RESULTS_DIR)/coverage-e2e.xml scripts/coverage_analysis.py | $(RESULTS_DIR)
	@echo "Generating coverage analysis report..."
	@uv sync --group test
	@export PYTHONPATH="src" && uv run python scripts/coverage_analysis.py
	@echo "TBD: Checking coverage threshold..."

coverage-html:
	@echo "Running tests with HTML coverage report..."
	@uv sync --group test
	@export PYTHONPATH="src" && uv run python -m pytest tests/ --cov=quilt_mcp --cov-report=html:htmlcov --cov-report=term-missing -v
	@echo "‚úÖ HTML coverage report generated in htmlcov/"
	@echo "üìä Open htmlcov/index.html in your browser to view the report"

test-scripts: scripts/tests/test_*.py | $(RESULTS_DIR)
	@echo "Running script tests (coverage analysis, workflow behavior)..."
	@uv sync --group test
	@if [ -d "scripts/tests" ] && [ "$$(find scripts/tests -name "*.py" | wc -l)" -gt 0 ]; then \
		export PYTHONPATH="src" && uv run python -m pytest scripts/tests/ -v; \
	else \
		echo "No script tests found"; \
	fi

# Code Quality Targets
lint:
	@echo "Running code linting and auto-fixing..."
	@uv sync --group lint
	@echo "Running ruff (format + lint + type check) - auto-fixing..."
	@uv run ruff format src/quilt_mcp/ tests/
	@uv run ruff check --fix src/quilt_mcp/ tests/
	@echo "‚úÖ All linting completed"

# Development Server Targets
run:
	@echo "Starting local MCP server..."
	@uv sync
	@echo "Server starting on $(DEV_ENDPOINT)"
	@export PYTHONPATH="src" && uv run python src/main.py

run-inspector:
	@echo "Launching MCP Inspector for visual testing..."
	@command -v npx >/dev/null || (echo "Error: npx not found. Please install Node.js first." && exit 1)
	@uv sync
	@echo "Starting MCP Inspector with server at $(DEV_ENDPOINT)"
	@echo "Inspector UI will be available at http://127.0.0.1:6274"
	@export PYTHONPATH="src" && npx @modelcontextprotocol/inspector uv run python src/main.py

kill:
	@echo "Killing running MCP server processes..."
	@pkill -f "python.*main.py" 2>/dev/null || echo "No main.py processes found"
	@pkill -f "python.*quilt_mcp" 2>/dev/null || echo "No quilt_mcp processes found"
	@pkill -f "@modelcontextprotocol/inspector" 2>/dev/null || echo "No MCP Inspector processes found"
	@lsof -ti :8000 | xargs -r kill 2>/dev/null || echo "No processes on port 8000"
	@lsof -ti :8001 | xargs -r kill 2>/dev/null || echo "No processes on port 8001"
	@echo "‚úÖ Server kill completed"

# Bucket Tool Testing with curl
# These tests validate the HTTP endpoint behavior of bucket operations

test-buckets-curl: test-buckets-discover test-buckets-browse test-buckets-file-access
	@echo "‚úÖ All bucket curl tests completed"

test-buckets-discover:
	@echo "üîç Testing buckets.discover via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@echo "Discovering accessible buckets..."
	@curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"buckets","arguments":{"action":"discover"}}}' \
		| python3 -m json.tool | tee $(RESULTS_DIR)/bucket-discover.json
	@echo "‚úÖ Bucket discovery test completed"

test-buckets-browse:
	@echo "üîç Testing buckets.object_link (browsing session) via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@echo "Testing object_link with package context..."
	@echo "Note: This requires _context with bucket/package/hash"
	@curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"buckets","arguments":{"action":"object_link","params":{"path":"README.md","_context":{"bucket":"quilt-example","package":"examples/wellplates","hash":"abc123"}}}}}' \
		| python3 -m json.tool | tee $(RESULTS_DIR)/bucket-object-link.json
	@echo "‚úÖ Bucket browsing session test completed"

test-buckets-file-access:
	@echo "üîç Testing bucket file access operations..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@echo "Testing object_info..."
	@curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"buckets","arguments":{"action":"object_info","params":{"path":"README.md","_context":{"bucket":"quilt-example","package":"examples/wellplates","hash":"abc123"}}}}}' \
		| python3 -m json.tool | tee $(RESULTS_DIR)/bucket-object-info.json
	@echo "Testing object_text..."
	@curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":6,"method":"tools/call","params":{"name":"buckets","arguments":{"action":"object_text","params":{"path":"README.md","_context":{"bucket":"quilt-example","package":"examples/wellplates","hash":"abc123"},"max_bytes":1024}}}}' \
		| python3 -m json.tool | tee $(RESULTS_DIR)/bucket-object-text.json
	@echo "‚úÖ File access tests completed"

# Package Tool Testing with curl
# These tests validate the HTTP endpoint behavior of packaging operations
# Note: discover/list removed - use search tool instead

test-packaging-curl: test-packaging-browse test-packaging-create
	@echo "‚úÖ All packaging curl tests completed"

test-packaging-browse:
	@echo "üîç Testing packaging.browse via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@if [ -z "$(TEST_PACKAGE_NAME)" ]; then \
		echo "‚ö†Ô∏è  TEST_PACKAGE_NAME not set, using default: demo-team/visualization-showcase"; \
		TEST_PKG="demo-team/visualization-showcase"; \
	else \
		TEST_PKG="$(TEST_PACKAGE_NAME)"; \
	fi; \
	echo "Testing package browse: $$TEST_PKG"; \
	echo ""; \
	echo "‚Üí Calling packaging.browse with package name..."; \
	RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d "{\"jsonrpc\":\"2.0\",\"id\":102,\"method\":\"tools/call\",\"params\":{\"name\":\"packaging\",\"arguments\":{\"action\":\"browse\",\"params\":{\"name\":\"$$TEST_PKG\"}}}}"); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/packaging-browse.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Package browse successful"; \
		ENTRY_COUNT=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(len(data.get('result', {}).get('package', {}).get('entries', [])))" 2>/dev/null || echo "0"); \
		echo "   Found $$ENTRY_COUNT entries in package"; \
	else \
		echo "‚ùå Package browse failed"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
		exit 1; \
	fi
	@echo ""
	@echo "‚úÖ Package browse test completed"

test-packaging-create:
	@echo "üîç Testing packaging.create via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo "‚ö†Ô∏è  Package creation requires pre-uploaded S3 files"
	@echo ""
	@echo "Test 1: Dry run validation with valid S3 URI..."
	@if [ -z "$(TEST_S3_URI)" ]; then \
		echo "‚ö†Ô∏è  TEST_S3_URI not set, using example URI"; \
		TEST_URI="s3://quilt-example/.quilt/packages/test/README.md"; \
	else \
		TEST_URI="$(TEST_S3_URI)"; \
	fi; \
	RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d "{\"jsonrpc\":\"2.0\",\"id\":103,\"method\":\"tools/call\",\"params\":{\"name\":\"packaging\",\"arguments\":{\"action\":\"create\",\"params\":{\"name\":\"quilt-example/test-pkg-curl\",\"files\":[\"$$TEST_URI\"],\"description\":\"Test package via curl\",\"metadata\":{\"source\":\"curl-test\",\"author\":\"mcp-server\"},\"dry_run\":true}}}}"); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/packaging-create-dry-run.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"dry_run": true'; then \
		echo "‚úÖ Dry run validation successful"; \
	else \
		echo "‚ùå Dry run validation failed"; \
		exit 1; \
	fi
	@echo ""
	@echo "Test 2: Error handling with missing package name..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":104,"method":"tools/call","params":{"name":"packaging","arguments":{"action":"create","params":{"files":["s3://bucket/file.txt"],"dry_run":true}}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/packaging-create-error-name.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": false'; then \
		echo "‚úÖ Error handling working (missing name detected)"; \
	else \
		echo "‚ö†Ô∏è  Expected error not returned"; \
	fi
	@echo ""
	@echo "Test 3: Error handling with missing files..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":105,"method":"tools/call","params":{"name":"packaging","arguments":{"action":"create","params":{"name":"bucket/test","description":"Test","dry_run":true}}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/packaging-create-error-files.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": false'; then \
		echo "‚úÖ Error handling working (missing files detected)"; \
	else \
		echo "‚ö†Ô∏è  Expected error not returned"; \
	fi
	@echo ""
	@echo "Test 4: Metadata and organization features..."
	@if [ -z "$(TEST_S3_URI)" ]; then \
		TEST_URI="s3://quilt-example/.quilt/packages/test/README.md"; \
	else \
		TEST_URI="$(TEST_S3_URI)"; \
	fi; \
	RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d "{\"jsonrpc\":\"2.0\",\"id\":106,\"method\":\"tools/call\",\"params\":{\"name\":\"packaging\",\"arguments\":{\"action\":\"create\",\"params\":{\"name\":\"quilt-example/test-pkg-organized\",\"files\":[\"$$TEST_URI\"],\"description\":\"Test with auto-organize\",\"metadata\":{\"test\":true,\"version\":\"1.0.0\"},\"auto_organize\":true,\"dry_run\":true}}}}"); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/packaging-create-organized.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"dry_run": true'; then \
		echo "‚úÖ Metadata and organization features working"; \
	else \
		echo "‚ö†Ô∏è  Organization test failed"; \
	fi
	@echo ""
	@echo "‚úÖ All package create tests completed"

# Permissions Tool Testing with curl
# These tests validate permissions discovery and access checking via GraphQL

test-permissions-curl: test-permissions-discover test-permissions-access-check test-permissions-recommendations test-permissions-module-info
	@echo "‚úÖ All permissions curl tests completed"

# Governance Tool Testing with curl
# These tests validate admin operations via GraphQL (requires admin privileges)

test-governance-curl: test-governance-users test-governance-roles test-governance-sso test-governance-tabulator
	@echo "‚úÖ All governance curl tests completed"

test-governance-users:
	@echo "üîç Testing governance user management via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test 1: List all users..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":401,"method":"tools/call","params":{"name":"governance","arguments":{"action":"users_list"}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/governance-users-list.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ User list successful"; \
		USER_COUNT=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('count', 0))" 2>/dev/null || echo "0"); \
		echo "   Total users: $$USER_COUNT"; \
	else \
		echo "‚ùå User list failed (may require admin privileges)"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
	fi
	@echo ""
	@echo "‚úÖ Governance user tests completed"

test-governance-roles:
	@echo "üîç Testing governance role management via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test 1: List all roles..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":402,"method":"tools/call","params":{"name":"governance","arguments":{"action":"roles_list"}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/governance-roles-list.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Role list successful"; \
		ROLE_COUNT=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('count', 0))" 2>/dev/null || echo "0"); \
		echo "   Total roles: $$ROLE_COUNT"; \
	else \
		echo "‚ùå Role list failed (may require admin privileges)"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
	fi
	@echo ""
	@echo "‚úÖ Governance role tests completed"

test-governance-sso:
	@echo "üîç Testing governance SSO config via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test 1: Get SSO configuration..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":403,"method":"tools/call","params":{"name":"governance","arguments":{"action":"sso_config_get"}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/governance-sso-get.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ SSO config retrieval successful"; \
		HAS_CONFIG=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print('Yes' if data.get('result', {}).get('sso_config') else 'No')" 2>/dev/null || echo "Unknown"); \
		echo "   SSO configured: $$HAS_CONFIG"; \
	else \
		echo "‚ùå SSO config retrieval failed (may require admin privileges)"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
	fi
	@echo ""
	@echo "‚úÖ Governance SSO tests completed"

test-governance-tabulator:
	@echo "üîç Testing governance tabulator settings via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test 1: Get tabulator open query status..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":404,"method":"tools/call","params":{"name":"governance","arguments":{"action":"tabulator_open_query_get"}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/governance-tabulator-open-query.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Tabulator open query status retrieval successful"; \
		OPEN_QUERY=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('open_query_enabled', False))" 2>/dev/null || echo "Unknown"); \
		echo "   Open query enabled: $$OPEN_QUERY"; \
	else \
		echo "‚ùå Tabulator open query status retrieval failed (may require admin privileges)"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
	fi
	@echo ""
	@echo "‚úÖ Governance tabulator tests completed"

test-permissions-discover:
	@echo "üîç Testing permissions.discover via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test 1: Discover all accessible buckets and user identity..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":200,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"discover"}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-discover.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Permissions discovery successful"; \
		USER_EMAIL=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('user_identity', {}).get('email', 'unknown'))" 2>/dev/null || echo "unknown"); \
		BUCKET_COUNT=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('total_buckets_checked', 0))" 2>/dev/null || echo "0"); \
		IS_ADMIN=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('user_identity', {}).get('is_admin', False))" 2>/dev/null || echo "False"); \
		echo "   User: $$USER_EMAIL"; \
		echo "   Admin: $$IS_ADMIN"; \
		echo "   Accessible buckets: $$BUCKET_COUNT"; \
	else \
		echo "‚ùå Permissions discovery failed"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
		exit 1; \
	fi
	@echo ""
	@echo "Test 2: Discover specific buckets (including non-existent)..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":201,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"discover","params":{"check_buckets":["quilt-example","nonexistent-test-bucket-xyz"]}}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-discover-filtered.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Filtered discovery successful"; \
		CHECKED=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('total_buckets_checked', 0))" 2>/dev/null || echo "0"); \
		echo "   Buckets checked: $$CHECKED (should be 2)"; \
	else \
		echo "‚ùå Filtered discovery failed"; \
	fi
	@echo ""
	@echo "Test 3: Error handling - no token..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-d '{"jsonrpc":"2.0","id":202,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"discover"}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-discover-no-token.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": false'; then \
		echo "‚úÖ Error handling working (no token detected)"; \
	else \
		echo "‚ö†Ô∏è  Expected authentication error not returned"; \
	fi
	@echo ""
	@echo "‚úÖ Permissions discovery tests completed"

test-permissions-access-check:
	@echo "üîç Testing permissions.access_check via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test 1: Check access to existing bucket (quilt-example)..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":210,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"access_check","params":{"bucket_name":"quilt-example"}}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-access-check-existing.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Access check successful"; \
		ACCESSIBLE=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('accessible', False))" 2>/dev/null || echo "False"); \
		PERMISSION=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('permission_level', 'unknown'))" 2>/dev/null || echo "unknown"); \
		echo "   Bucket: quilt-example"; \
		echo "   Accessible: $$ACCESSIBLE"; \
		echo "   Permission Level: $$PERMISSION"; \
	else \
		echo "‚ùå Access check failed"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
		exit 1; \
	fi
	@echo ""
	@echo "Test 2: Check access to non-existent bucket..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":211,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"access_check","params":{"bucket_name":"definitely-does-not-exist-xyz-123"}}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-access-check-nonexistent.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		ACCESSIBLE=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('accessible', True))" 2>/dev/null || echo "True"); \
		PERMISSION=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('permission_level', ''))" 2>/dev/null || echo ""); \
		if [ "$$ACCESSIBLE" = "False" ] && [ "$$PERMISSION" = "no_access" ]; then \
			echo "‚úÖ Non-existent bucket correctly identified as inaccessible"; \
		else \
			echo "‚ö†Ô∏è  Unexpected result for non-existent bucket"; \
		fi; \
	else \
		echo "‚ùå Access check for non-existent bucket failed"; \
	fi
	@echo ""
	@echo "Test 3: Check access with alias action name (check_bucket_access)..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":212,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"check_bucket_access","params":{"bucket":"quilt-example"}}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-check-bucket-access.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Alias action (check_bucket_access) working correctly"; \
	else \
		echo "‚ùå Alias action failed"; \
	fi
	@echo ""
	@echo "Test 4: Error handling - missing bucket name..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":213,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"access_check","params":{}}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-access-check-no-bucket.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": false'; then \
		echo "‚úÖ Error handling working (missing bucket name detected)"; \
	else \
		echo "‚ö†Ô∏è  Expected validation error not returned"; \
	fi
	@echo ""
	@echo "‚úÖ Permissions access check tests completed"

test-permissions-recommendations:
	@echo "üîç Testing permissions.recommendations_get via curl..."
	@if [ -z "$(QUILT_TEST_TOKEN)" ]; then \
		echo "‚ùå QUILT_TEST_TOKEN not set. Set with: export QUILT_TEST_TOKEN=<token>"; \
		exit 1; \
	fi
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test 1: Get permission recommendations..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-H "Authorization: Bearer $(QUILT_TEST_TOKEN)" \
		-d '{"jsonrpc":"2.0","id":220,"method":"tools/call","params":{"name":"permissions","arguments":{"action":"recommendations_get"}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-recommendations.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"success": true'; then \
		echo "‚úÖ Recommendations retrieved successfully"; \
		REC_COUNT=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(len(data.get('result', {}).get('recommendations', [])))" 2>/dev/null || echo "0"); \
		echo "   Recommendations: $$REC_COUNT"; \
		if [ "$$REC_COUNT" -gt "0" ]; then \
			echo "   First recommendation:"; \
			echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); recs=data.get('result', {}).get('recommendations', []); print('     Priority:', recs[0].get('priority', 'N/A')) if recs else None; print('     Message:', recs[0].get('message', 'N/A')) if recs else None" 2>/dev/null || echo "     (could not parse)"; \
		fi; \
	else \
		echo "‚ùå Recommendations retrieval failed"; \
		ERROR=$$(echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('error', 'Unknown error'))" 2>/dev/null || echo "Parse error"); \
		echo "   Error: $$ERROR"; \
		exit 1; \
	fi
	@echo ""
	@echo "‚úÖ Permissions recommendations tests completed"

test-permissions-module-info:
	@echo "üîç Testing permissions module discovery (no action)..."
	@mkdir -p $(RESULTS_DIR)
	@echo ""
	@echo "Test: Get permissions module info..."
	@RESPONSE=$$(curl -s -X POST $(DEV_ENDPOINT) \
		-H "Content-Type: application/json" \
		-d '{"jsonrpc":"2.0","id":230,"method":"tools/call","params":{"name":"permissions","arguments":{}}}'); \
	echo "$$RESPONSE" | python3 -m json.tool | tee $(RESULTS_DIR)/permissions-module-info.json; \
	echo ""; \
	if echo "$$RESPONSE" | grep -q '"module": "permissions"'; then \
		echo "‚úÖ Module info retrieved successfully"; \
		echo "   Available actions:"; \
		echo "$$RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); actions=data.get('result', {}).get('actions', []); [print(f'     - {a}') for a in actions]" 2>/dev/null || echo "     (could not parse)"; \
	else \
		echo "‚ùå Module info retrieval failed"; \
	fi
	@echo ""
	@echo "‚úÖ Permissions module info test completed"

test-readme:
	@echo "üîç Testing README validation..."
	@test -f README.md || { echo "‚ùå README.md missing"; exit 1; }
	@grep -q "Quilt MCP Server" README.md || { echo "‚ùå README missing project name"; exit 1; }
	@echo "‚úÖ README validation passed"

# Cleanup Targets
dev-clean:
	@echo "Cleaning Python cache..."
	@find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete 2>/dev/null || true
	@echo "Cleaning test artifacts..."
	@rm -rf $(RESULTS_DIR)/ .coverage .coverage.* htmlcov/ .pytest_cache/ 2>/dev/null || true
	@find . -name "*.egg-info" -type d -exec rm -rf {} + 2>/dev/null || true
	@echo "Cleaning build artifacts..."
	@rm -rf build/ dist/ .ruff_cache/ 2>/dev/null || true
	@find . -name ".DS_Store" -delete 2>/dev/null || true
	@echo "‚úÖ Development cleanup completed"
